{"version":3,"file":"index.umd.min.js","sources":["../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/typeof.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/createClass.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/common.js","../../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec3.js","../../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec2.js","../src/CanvasPickerPlugin.ts","../../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/mat4.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/.pnpm/@antv+util@3.3.5/node_modules/@antv/util/esm/lodash/clamp.js","../../../node_modules/.pnpm/@antv+util@3.3.5/node_modules/@antv/util/esm/path/util/rotate-vector.js","../../../node_modules/.pnpm/@antv+util@3.3.5/node_modules/@antv/util/esm/path/process/arc-2-cubic.js","../../g-math/dist/index.esm.js","../src/Circle.ts","../src/Ellipse.ts","../src/utils/math.ts","../src/Line.ts","../src/Path.ts","../src/Polygon.ts","../src/Polyline.ts","../src/Rect.ts","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/Image.ts","../src/Text.ts","../src/index.ts","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/callSuper.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/inherits.js"],"sourcesContent":["function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nexport { _defineProperty as default };","function _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nexport { _classCallCheck as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };","function _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nexport { _getPrototypeOf as default };","function _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nexport { _isNativeReflectConstruct as default };","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return assertThisInitialized(t);\n}\nexport { _possibleConstructorReturn as default };","function _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nexport { _assertThisInitialized as default };","function _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nexport { _setPrototypeOf as default };","function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };","import _typeof from \"./typeof.js\";\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  _regeneratorRuntime = function _regeneratorRuntime() {\n    return e;\n  };\n  var t,\n    e = {},\n    r = Object.prototype,\n    n = r.hasOwnProperty,\n    o = Object.defineProperty || function (t, e, r) {\n      t[e] = r.value;\n    },\n    i = \"function\" == typeof Symbol ? Symbol : {},\n    a = i.iterator || \"@@iterator\",\n    c = i.asyncIterator || \"@@asyncIterator\",\n    u = i.toStringTag || \"@@toStringTag\";\n  function define(t, e, r) {\n    return Object.defineProperty(t, e, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), t[e];\n  }\n  try {\n    define({}, \"\");\n  } catch (t) {\n    define = function define(t, e, r) {\n      return t[e] = r;\n    };\n  }\n  function wrap(t, e, r, n) {\n    var i = e && e.prototype instanceof Generator ? e : Generator,\n      a = Object.create(i.prototype),\n      c = new Context(n || []);\n    return o(a, \"_invoke\", {\n      value: makeInvokeMethod(t, r, c)\n    }), a;\n  }\n  function tryCatch(t, e, r) {\n    try {\n      return {\n        type: \"normal\",\n        arg: t.call(e, r)\n      };\n    } catch (t) {\n      return {\n        type: \"throw\",\n        arg: t\n      };\n    }\n  }\n  e.wrap = wrap;\n  var h = \"suspendedStart\",\n    l = \"suspendedYield\",\n    f = \"executing\",\n    s = \"completed\",\n    y = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var p = {};\n  define(p, a, function () {\n    return this;\n  });\n  var d = Object.getPrototypeOf,\n    v = d && d(d(values([])));\n  v && v !== r && n.call(v, a) && (p = v);\n  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n  function defineIteratorMethods(t) {\n    [\"next\", \"throw\", \"return\"].forEach(function (e) {\n      define(t, e, function (t) {\n        return this._invoke(e, t);\n      });\n    });\n  }\n  function AsyncIterator(t, e) {\n    function invoke(r, o, i, a) {\n      var c = tryCatch(t[r], t, o);\n      if (\"throw\" !== c.type) {\n        var u = c.arg,\n          h = u.value;\n        return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n          invoke(\"next\", t, i, a);\n        }, function (t) {\n          invoke(\"throw\", t, i, a);\n        }) : e.resolve(h).then(function (t) {\n          u.value = t, i(u);\n        }, function (t) {\n          return invoke(\"throw\", t, i, a);\n        });\n      }\n      a(c.arg);\n    }\n    var r;\n    o(this, \"_invoke\", {\n      value: function value(t, n) {\n        function callInvokeWithMethodAndArg() {\n          return new e(function (e, r) {\n            invoke(t, n, e, r);\n          });\n        }\n        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(e, r, n) {\n    var o = h;\n    return function (i, a) {\n      if (o === f) throw Error(\"Generator is already running\");\n      if (o === s) {\n        if (\"throw\" === i) throw a;\n        return {\n          value: t,\n          done: !0\n        };\n      }\n      for (n.method = i, n.arg = a;;) {\n        var c = n.delegate;\n        if (c) {\n          var u = maybeInvokeDelegate(c, n);\n          if (u) {\n            if (u === y) continue;\n            return u;\n          }\n        }\n        if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n          if (o === h) throw o = s, n.arg;\n          n.dispatchException(n.arg);\n        } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n        o = f;\n        var p = tryCatch(e, r, n);\n        if (\"normal\" === p.type) {\n          if (o = n.done ? s : l, p.arg === y) continue;\n          return {\n            value: p.arg,\n            done: n.done\n          };\n        }\n        \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(e, r) {\n    var n = r.method,\n      o = e.iterator[n];\n    if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n    var i = tryCatch(o, e.iterator, r.arg);\n    if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n    var a = i.arg;\n    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n  }\n  function pushTryEntry(t) {\n    var e = {\n      tryLoc: t[0]\n    };\n    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n  }\n  function resetTryEntry(t) {\n    var e = t.completion || {};\n    e.type = \"normal\", delete e.arg, t.completion = e;\n  }\n  function Context(t) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], t.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(e) {\n    if (e || \"\" === e) {\n      var r = e[a];\n      if (r) return r.call(e);\n      if (\"function\" == typeof e.next) return e;\n      if (!isNaN(e.length)) {\n        var o = -1,\n          i = function next() {\n            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n            return next.value = t, next.done = !0, next;\n          };\n        return i.next = i;\n      }\n    }\n    throw new TypeError(_typeof(e) + \" is not iterable\");\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), o(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n    var e = \"function\" == typeof t && t.constructor;\n    return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n  }, e.mark = function (t) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n  }, e.awrap = function (t) {\n    return {\n      __await: t\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n    return this;\n  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n    void 0 === i && (i = Promise);\n    var a = new AsyncIterator(wrap(t, r, n, o), i);\n    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n      return t.done ? t.value : a.next();\n    });\n  }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n    return this;\n  }), define(g, \"toString\", function () {\n    return \"[object Generator]\";\n  }), e.keys = function (t) {\n    var e = Object(t),\n      r = [];\n    for (var n in e) r.push(n);\n    return r.reverse(), function next() {\n      for (; r.length;) {\n        var t = r.pop();\n        if (t in e) return next.value = t, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, e.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(e) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var t = this.tryEntries[0].completion;\n      if (\"throw\" === t.type) throw t.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(e) {\n      if (this.done) throw e;\n      var r = this;\n      function handle(n, o) {\n        return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n      }\n      for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n        var i = this.tryEntries[o],\n          a = i.completion;\n        if (\"root\" === i.tryLoc) return handle(\"end\");\n        if (i.tryLoc <= this.prev) {\n          var c = n.call(i, \"catchLoc\"),\n            u = n.call(i, \"finallyLoc\");\n          if (c && u) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          } else if (c) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n          } else {\n            if (!u) throw Error(\"try statement without catch or finally\");\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(t, e) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var o = this.tryEntries[r];\n        if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n          var i = o;\n          break;\n        }\n      }\n      i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n      var a = i ? i.completion : {};\n      return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n    },\n    complete: function complete(t, e) {\n      if (\"throw\" === t.type) throw t.arg;\n      return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n    },\n    finish: function finish(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n      }\n    },\n    \"catch\": function _catch(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.tryLoc === t) {\n          var n = r.completion;\n          if (\"throw\" === n.type) {\n            var o = n.arg;\n            resetTryEntry(r);\n          }\n          return o;\n        }\n      }\n      throw Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(e, r, n) {\n      return this.delegate = {\n        iterator: values(e),\n        resultName: r,\n        nextLoc: n\n      }, \"next\" === this.method && (this.arg = t), y;\n    }\n  }, e;\n}\nexport { _regeneratorRuntime as default };","function asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nexport { _asyncToGenerator as default };","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","import type {\n  BaseStyleProps,\n  DisplayObject,\n  ParsedBaseStyleProps,\n  PickingResult,\n  RenderingPlugin,\n  Shape,\n  IDocument,\n  RenderingPluginContext,\n  GlobalRuntime,\n} from '@antv/g-lite';\nimport { findClosestClipPathTarget, Point } from '@antv/g-lite';\nimport type { PathGenerator } from '@antv/g-plugin-canvas-path-generator';\nimport { mat4, vec3 } from 'gl-matrix';\n\nexport type PointInPathPicker<T extends BaseStyleProps> = (\n  displayObject: DisplayObject<T>,\n  point: Point,\n  isClipPath: boolean,\n  isPointInPath: (displayObject: DisplayObject<T>, point: Point) => boolean,\n  context: RenderingPluginContext,\n  runtime: GlobalRuntime,\n) => boolean;\n\nconst tmpVec3a = vec3.create();\nconst tmpVec3b = vec3.create();\nconst tmpVec3c = vec3.create();\nconst tmpMat4 = mat4.create();\n\ninterface Extended {\n  pathGeneratorFactory: Record<Shape, PathGenerator<any>>;\n  pointInPathPickerFactory: Record<Shape, PointInPathPicker<any>>;\n}\n\n/**\n * pick shape(s) with Mouse/Touch event\n *\n * 1. find AABB with r-tree\n * 2. do math calculation with geometry in an accurate way\n */\nexport class CanvasPickerPlugin implements RenderingPlugin {\n  static tag = 'CanvasPicker';\n\n  private context: RenderingPluginContext & Extended;\n  private runtime: GlobalRuntime;\n\n  apply(context: RenderingPluginContext, runtime: GlobalRuntime) {\n    const { renderingService, renderingContext } = context;\n    this.context = context as RenderingPluginContext & Extended;\n    this.runtime = runtime;\n\n    const document = renderingContext.root?.ownerDocument;\n\n    renderingService.hooks.pick.tapPromise(\n      CanvasPickerPlugin.tag,\n      async (result: PickingResult) => {\n        return this.pick(document, result);\n      },\n    );\n\n    renderingService.hooks.pickSync.tap(\n      CanvasPickerPlugin.tag,\n      (result: PickingResult) => {\n        return this.pick(document, result);\n      },\n    );\n  }\n\n  private pick(document: IDocument, result: PickingResult) {\n    const {\n      topmost,\n      position: { x, y },\n    } = result;\n\n    // position in world space\n    const position = vec3.set(tmpVec3a, x, y, 0);\n\n    // query by AABB first with spatial index(r-tree)\n    const hitTestList = document.elementsFromBBox(\n      position[0],\n      position[1],\n      position[0],\n      position[1],\n    );\n\n    // test with clip path & origin shape\n    // @see https://github.com/antvis/g/issues/1064\n    const pickedDisplayObjects: DisplayObject[] = [];\n    for (const displayObject of hitTestList) {\n      const worldTransform = displayObject.getWorldTransform();\n      const isHitOriginShape = this.isHit(\n        displayObject,\n        position,\n        worldTransform,\n        false,\n      );\n      if (isHitOriginShape) {\n        // should look up in the ancestor node\n        const clipped = findClosestClipPathTarget(displayObject);\n        if (clipped) {\n          const { clipPath } = clipped.parsedStyle as ParsedBaseStyleProps;\n          const isHitClipPath = this.isHit(\n            clipPath,\n            position,\n            clipPath.getWorldTransform(),\n            true,\n          );\n          if (isHitClipPath) {\n            if (topmost) {\n              result.picked = [displayObject];\n              return result;\n            }\n            pickedDisplayObjects.push(displayObject);\n          }\n        } else {\n          if (topmost) {\n            result.picked = [displayObject];\n            return result;\n          }\n          pickedDisplayObjects.push(displayObject);\n        }\n      }\n    }\n\n    result.picked = pickedDisplayObjects;\n    return result;\n  }\n\n  private isHit = (\n    displayObject: DisplayObject,\n    position: vec3,\n    worldTransform: mat4,\n    isClipPath: boolean,\n  ) => {\n    // use picker for current shape's type\n    const pick =\n      this.context.pointInPathPickerFactory[displayObject.nodeName as Shape];\n    if (pick) {\n      // invert with world matrix\n      const invertWorldMat = mat4.invert(tmpMat4, worldTransform);\n\n      // transform client position to local space, do picking in local space\n      const localPosition = vec3.transformMat4(\n        tmpVec3b,\n        vec3.set(tmpVec3c, position[0], position[1], 0),\n        invertWorldMat,\n      );\n\n      if (\n        pick(\n          displayObject,\n          new Point(localPosition[0], localPosition[1]),\n          isClipPath,\n          this.isPointInPath,\n          this.context,\n          this.runtime,\n        )\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * use native picking method\n   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath\n   */\n  private isPointInPath = (displayObject: DisplayObject, position: Point) => {\n    const context = this.runtime.offscreenCanvasCreator.getOrCreateContext(\n      this.context.config.offscreenCanvas,\n    ) as CanvasRenderingContext2D;\n\n    const generatePath =\n      this.context.pathGeneratorFactory[displayObject.nodeName];\n    if (generatePath) {\n      context.beginPath();\n      generatePath(context, displayObject.parsedStyle);\n      context.closePath();\n    }\n\n    return context.isPointInPath(position.x, position.y);\n  };\n}\n","import * as glMatrix from \"./common.js\";\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nexport function adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nexport function determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nexport function translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nexport function scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nexport function fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nexport function fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nexport function fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nexport function getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nexport function getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nexport function fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nexport var perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nexport function perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nexport var ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nexport function orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nexport function targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nexport function str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nexport function frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nexport var sub = subtract;","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var _n = 0,\n        F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          return _n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[_n++]\n          };\n        },\n        e: function e(r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function s() {\n      t = t.call(r);\n    },\n    n: function n() {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function e(r) {\n      u = !0, o = r;\n    },\n    f: function f() {\n      try {\n        a || null == t[\"return\"] || t[\"return\"]();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nexport { _createForOfIteratorHelper as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nfunction _toConsumableArray(r) {\n  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();\n}\nexport { _toConsumableArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return arrayLikeToArray(r);\n}\nexport { _arrayWithoutHoles as default };","function _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nexport { _iterableToArray as default };","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableSpread as default };","var clamp = function (a, min, max) {\n    if (a < min) {\n        return min;\n    }\n    else if (a > max) {\n        return max;\n    }\n    return a;\n};\nexport default clamp;\n//# sourceMappingURL=clamp.js.map","export function rotateVector(x, y, rad) {\n    var X = x * Math.cos(rad) - y * Math.sin(rad);\n    var Y = x * Math.sin(rad) + y * Math.cos(rad);\n    return { x: X, y: Y };\n}\n//# sourceMappingURL=rotate-vector.js.map","import { rotateVector } from '../util/rotate-vector';\n/**\n * Converts A (arc-to) segments to C (cubic-bezier-to).\n *\n * For more information of where this math came from visit:\n * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n */\nexport function arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {\n    var x1 = X1;\n    var y1 = Y1;\n    var rx = RX;\n    var ry = RY;\n    var x2 = X2;\n    var y2 = Y2;\n    // for more information of where this Math came from visit:\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n    var d120 = (Math.PI * 120) / 180;\n    var rad = (Math.PI / 180) * (+angle || 0);\n    /** @type {number[]} */\n    var res = [];\n    var xy;\n    var f1;\n    var f2;\n    var cx;\n    var cy;\n    if (!recursive) {\n        xy = rotateVector(x1, y1, -rad);\n        x1 = xy.x;\n        y1 = xy.y;\n        xy = rotateVector(x2, y2, -rad);\n        x2 = xy.x;\n        y2 = xy.y;\n        var x = (x1 - x2) / 2;\n        var y = (y1 - y2) / 2;\n        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            rx *= h;\n            ry *= h;\n        }\n        var rx2 = rx * rx;\n        var ry2 = ry * ry;\n        var k = (LAF === SF ? -1 : 1) *\n            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n        cx = (k * rx * y) / ry + (x1 + x2) / 2;\n        cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n        // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n        f1 = Math.asin(((((y1 - cy) / ry) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9));\n        // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise\n        f2 = Math.asin(((((y2 - cy) / ry) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9));\n        f1 = x1 < cx ? Math.PI - f1 : f1;\n        f2 = x2 < cx ? Math.PI - f2 : f2;\n        if (f1 < 0)\n            f1 = Math.PI * 2 + f1;\n        if (f2 < 0)\n            f2 = Math.PI * 2 + f2;\n        if (SF && f1 > f2) {\n            f1 -= Math.PI * 2;\n        }\n        if (!SF && f2 > f1) {\n            f2 -= Math.PI * 2;\n        }\n    }\n    else {\n        f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];\n    }\n    var df = f2 - f1;\n    if (Math.abs(df) > d120) {\n        var f2old = f2;\n        var x2old = x2;\n        var y2old = y2;\n        f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * Math.cos(f2);\n        y2 = cy + ry * Math.sin(f2);\n        res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    var c1 = Math.cos(f1);\n    var s1 = Math.sin(f1);\n    var c2 = Math.cos(f2);\n    var s2 = Math.sin(f2);\n    var t = Math.tan(df / 4);\n    var hx = (4 / 3) * rx * t;\n    var hy = (4 / 3) * ry * t;\n    var m1 = [x1, y1];\n    var m2 = [x1 + hx * s1, y1 - hy * c1];\n    var m3 = [x2 + hx * s2, y2 - hy * c2];\n    var m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return m2.concat(m3, m4, res);\n        // return [...m2, ...m3, ...m4, ...res];\n    }\n    res = m2.concat(m3, m4, res);\n    // res = [...m2, ...m3, ...m4, ...res];\n    var newres = [];\n    for (var i = 0, ii = res.length; i < ii; i += 1) {\n        newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;\n    }\n    return newres;\n}\n// const TAU = Math.PI * 2;\n// const mapToEllipse = (\n//   { x, y }: { x: number; y: number },\n//   rx: number,\n//   ry: number,\n//   cosphi: number,\n//   sinphi: number,\n//   centerx: number,\n//   centery: number,\n// ) => {\n//   x *= rx;\n//   y *= ry;\n//   const xp = cosphi * x - sinphi * y;\n//   const yp = sinphi * x + cosphi * y;\n//   return {\n//     x: xp + centerx,\n//     y: yp + centery,\n//   };\n// };\n// const approxUnitArc = (ang1: number, ang2: number) => {\n//   // If 90 degree circular arc, use a constant\n//   // as derived from http://spencermortensen.com/articles/bezier-circle\n//   const a =\n//     ang2 === 1.5707963267948966\n//       ? 0.551915024494\n//       : ang2 === -1.5707963267948966\n//       ? -0.551915024494\n//       : (4 / 3) * Math.tan(ang2 / 4);\n//   const x1 = Math.cos(ang1);\n//   const y1 = Math.sin(ang1);\n//   const x2 = Math.cos(ang1 + ang2);\n//   const y2 = Math.sin(ang1 + ang2);\n//   return [\n//     {\n//       x: x1 - y1 * a,\n//       y: y1 + x1 * a,\n//     },\n//     {\n//       x: x2 + y2 * a,\n//       y: y2 - x2 * a,\n//     },\n//     {\n//       x: x2,\n//       y: y2,\n//     },\n//   ];\n// };\n// const vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {\n//   const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n//   let dot = ux * vx + uy * vy;\n//   if (dot > 1) {\n//     dot = 1;\n//   }\n//   if (dot < -1) {\n//     dot = -1;\n//   }\n//   return sign * Math.acos(dot);\n// };\n// const getArcCenter = (\n//   px: any,\n//   py: any,\n//   cx: any,\n//   cy: any,\n//   rx: number,\n//   ry: number,\n//   largeArcFlag: number,\n//   sweepFlag: number,\n//   sinphi: number,\n//   cosphi: number,\n//   pxp: number,\n//   pyp: number,\n// ) => {\n//   const rxsq = Math.pow(rx, 2);\n//   const rysq = Math.pow(ry, 2);\n//   const pxpsq = Math.pow(pxp, 2);\n//   const pypsq = Math.pow(pyp, 2);\n//   let radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n//   if (radicant < 0) {\n//     radicant = 0;\n//   }\n//   radicant /= rxsq * pypsq + rysq * pxpsq;\n//   radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n//   const centerxp = ((radicant * rx) / ry) * pyp;\n//   const centeryp = ((radicant * -ry) / rx) * pxp;\n//   const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n//   const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n//   const vx1 = (pxp - centerxp) / rx;\n//   const vy1 = (pyp - centeryp) / ry;\n//   const vx2 = (-pxp - centerxp) / rx;\n//   const vy2 = (-pyp - centeryp) / ry;\n//   const ang1 = vectorAngle(1, 0, vx1, vy1);\n//   let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n//   if (sweepFlag === 0 && ang2 > 0) {\n//     ang2 -= TAU;\n//   }\n//   if (sweepFlag === 1 && ang2 < 0) {\n//     ang2 += TAU;\n//   }\n//   return [centerx, centery, ang1, ang2];\n// };\n// const arcToBezier = ({ px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0 }) => {\n//   const curves = [];\n//   if (rx === 0 || ry === 0) {\n//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n//   }\n//   const sinphi = Math.sin((xAxisRotation * TAU) / 360);\n//   const cosphi = Math.cos((xAxisRotation * TAU) / 360);\n//   const pxp = (cosphi * (px - cx)) / 2 + (sinphi * (py - cy)) / 2;\n//   const pyp = (-sinphi * (px - cx)) / 2 + (cosphi * (py - cy)) / 2;\n//   if (pxp === 0 && pyp === 0) {\n//     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];\n//   }\n//   rx = Math.abs(rx);\n//   ry = Math.abs(ry);\n//   const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n//   if (lambda > 1) {\n//     rx *= Math.sqrt(lambda);\n//     ry *= Math.sqrt(lambda);\n//   }\n//   let [centerx, centery, ang1, ang2] = getArcCenter(\n//     px,\n//     py,\n//     cx,\n//     cy,\n//     rx,\n//     ry,\n//     largeArcFlag,\n//     sweepFlag,\n//     sinphi,\n//     cosphi,\n//     pxp,\n//     pyp,\n//   );\n//   // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n//   // 1.0000000001. This causes `segments` to be greater than one, which is an\n//   // unecessary split, and adds extra points to the bezier curve. To alleviate\n//   // this issue, we round to 1.0 when the ratio is close to 1.0.\n//   let ratio = Math.abs(ang2) / (TAU / 4);\n//   if (Math.abs(1.0 - ratio) < 0.0000001) {\n//     ratio = 1.0;\n//   }\n//   const segments = Math.max(Math.ceil(ratio), 1);\n//   ang2 /= segments;\n//   for (let i = 0; i < segments; i++) {\n//     curves.push(approxUnitArc(ang1, ang2));\n//     ang1 += ang2;\n//   }\n//   return curves.map((curve) => {\n//     const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);\n//     const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);\n//     const { x, y } = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);\n//     return { x1, y1, x2, y2, x, y };\n//   });\n// };\n// export function arcToCubic(\n//   x1: number,\n//   y1: number,\n//   rx: number,\n//   ry: number,\n//   angle: number,\n//   LAF: number,\n//   SF: number,\n//   x2: number,\n//   y2: number,\n// ) {\n//   const curves = arcToBezier({\n//     px: x1,\n//     py: y1,\n//     cx: x2,\n//     cy: y2,\n//     rx,\n//     ry,\n//     xAxisRotation: angle,\n//     largeArcFlag: LAF,\n//     sweepFlag: SF,\n//   });\n//   return curves.reduce((prev, cur) => {\n//     const { x1, y1, x2, y2, x, y } = cur;\n//     prev.push(x1, y1, x2, y2, x, y);\n//     return prev;\n//   }, [] as number[]);\n// }\n//# sourceMappingURL=arc-2-cubic.js.map","/*!\n * @antv/g-math\n * @description Geometry util\n * @version 3.0.0\n * @date 10/23/2024, 11:13:25 AM\n * @author AntVis\n * @docs https://g.antv.antgroup.com/\n */\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport { isNumberEqual } from '@antv/util';\nimport { vec2 } from 'gl-matrix';\n\nfunction distance(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\nfunction getBBoxByArray(xArr, yArr) {\n  var minX = Math.min.apply(Math, _toConsumableArray(xArr));\n  var minY = Math.min.apply(Math, _toConsumableArray(yArr));\n  var maxX = Math.max.apply(Math, _toConsumableArray(xArr));\n  var maxY = Math.max.apply(Math, _toConsumableArray(yArr));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction piMod(angle) {\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\nfunction nearestPoint$4(x, y, rx, ry, x0, y0) {\n  var a = rx;\n  var b = ry;\n  // 假如椭圆半径为0则返回圆心\n  if (a === 0 || b === 0) {\n    return {\n      x: x,\n      y: y\n    };\n  }\n  // 转换成 0， 0 为中心的椭圆计算\n  var relativeX = x0 - x;\n  var relativeY = y0 - y;\n  var px = Math.abs(relativeX);\n  var py = Math.abs(relativeY);\n  var squareA = a * a;\n  var squareB = b * b;\n  // const angle0 = Math.atan2(relativeY, relativeX);\n  var t = Math.PI / 4;\n  var nearestX = 0; // 椭圆上的任一点\n  var nearestY = 0;\n  // 迭代 4 次\n  for (var i = 0; i < 4; i++) {\n    nearestX = a * Math.cos(t);\n    nearestY = b * Math.sin(t);\n    var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n    var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n    var rx1 = nearestX - ex;\n    var ry1 = nearestY - ey;\n    var qx = px - ex;\n    var qy = py - ey;\n    var r = Math.hypot(ry1, rx1);\n    var q = Math.hypot(qy, qx);\n    var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n    var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n    t += delta_t;\n    t = Math.min(Math.PI / 2, Math.max(0, t));\n  }\n  return {\n    x: x + copysign(nearestX, relativeX),\n    y: y + copysign(nearestY, relativeY)\n  };\n}\n\n// 偏导数 x\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n\n// 偏导数 y\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n\n// x 的极值\nfunction xExtrema(rx, ry, xRotation) {\n  return Math.atan(-ry / rx * Math.tan(xRotation));\n}\n\n// y 的极值\nfunction yExtrema(rx, ry, xRotation) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n\n// 根据角度求 x 坐标\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n\n// 根据角度求 y 坐标\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n\n// 获取点在椭圆上的角度\nfunction getAngle(rx, ry, x0, y0) {\n  var angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\n// 根据角度获取，x,y\nfunction getPoint(rx, ry, angle) {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle)\n  };\n}\n\n// 旋转\nfunction rotate(x, y, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\nfunction box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n  var xDim = xExtrema(rx, ry, xRotation);\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var xs = [startAngle, endAngle];\n  for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    var xAngle = xDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < xAngle && xAngle < endAngle) {\n        xs.push(xAngle);\n      }\n    } else if (endAngle < xAngle && xAngle < startAngle) {\n      xs.push(xAngle);\n    }\n  }\n  for (var _i = 0; _i < xs.length; _i++) {\n    var x = xAt(cx, cy, rx, ry, xRotation, xs[_i]);\n    if (x < minX) {\n      minX = x;\n    }\n    if (x > maxX) {\n      maxX = x;\n    }\n  }\n  var yDim = yExtrema(rx, ry, xRotation);\n  var minY = Infinity;\n  var maxY = -Infinity;\n  var ys = [startAngle, endAngle];\n  for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {\n    var yAngle = yDim + _i2;\n    if (startAngle < endAngle) {\n      if (startAngle < yAngle && yAngle < endAngle) {\n        ys.push(yAngle);\n      }\n    } else if (endAngle < yAngle && yAngle < startAngle) {\n      ys.push(yAngle);\n    }\n  }\n  for (var _i3 = 0; _i3 < ys.length; _i3++) {\n    var y = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);\n    if (y < minY) {\n      minY = y;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction nearestPoint$3(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n  // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n  var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n  var _relativeVector = _slicedToArray(relativeVector, 2),\n    x1 = _relativeVector[0],\n    y1 = _relativeVector[1];\n  // 计算点到椭圆的最近的点\n  var relativePoint = nearestPoint$4(0, 0, rx, ry, x1, y1);\n  // 获取点在椭圆上的角度\n  var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n  // 点没有在圆弧上\n  if (angle < startAngle) {\n    // 小于起始圆弧\n    relativePoint = getPoint(rx, ry, startAngle);\n  } else if (angle > endAngle) {\n    // 大于结束圆弧\n    relativePoint = getPoint(rx, ry, endAngle);\n  }\n  // 旋转到 xRotation 的角度\n  var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n  return {\n    x: vector[0] + cx,\n    y: vector[1] + cy\n  };\n}\nfunction tangentAngle$4(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n  var angle = (endAngle - startAngle) * t + startAngle;\n  var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n  var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n  return piMod(Math.atan2(dy, dx));\n}\n\nvar EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nfunction nearestPoint$2(xArr, yArr, x, y, tCallback, length) {\n  var t = -1;\n  var d = Infinity;\n  var v0 = [x, y];\n  var segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  var increaseRate = 1 / segNum;\n  var interval = increaseRate / 10;\n  for (var i = 0; i <= segNum; i++) {\n    var _t = i * increaseRate;\n    var v1 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([_t])))];\n    var d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0]\n    };\n  }\n  if (t === 1) {\n    var count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1]\n    };\n  }\n  d = Infinity;\n  for (var _i = 0; _i < 32; _i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n    var prev = t - interval;\n    var next = t + interval;\n    var _v = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([prev])))];\n    var _d = distance(v0[0], v0[1], _v[0], _v[1]);\n    if (prev >= 0 && _d < d) {\n      t = prev;\n      d = _d;\n    } else {\n      var v2 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([next])))];\n      var d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n  return {\n    x: tCallback.apply(void 0, _toConsumableArray(xArr.concat([t]))),\n    y: tCallback.apply(void 0, _toConsumableArray(yArr.concat([t])))\n  };\n}\n\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nfunction snapLength(xArr, yArr) {\n  var totalLength = 0;\n  var count = xArr.length;\n  for (var i = 0; i < count; i++) {\n    var x = xArr[i];\n    var y = yArr[i];\n    var nextX = xArr[(i + 1) % count];\n    var nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}\n\nfunction box$4(x1, y1, x2, y2) {\n  return getBBoxByArray([x1, x2], [y1, y2]);\n}\nfunction length$4(x1, y1, x2, y2) {\n  return distance(x1, y1, x2, y2);\n}\nfunction pointAt$3(x1, y1, x2, y2, t) {\n  return {\n    x: (1 - t) * x1 + t * x2,\n    y: (1 - t) * y1 + t * y2\n  };\n}\nfunction pointDistance$4(x1, y1, x2, y2, x, y) {\n  // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n  // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n  var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n  if (cross < 0) {\n    return distance(x1, y1, x, y);\n  }\n  var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  if (cross > lengthSquare) {\n    return distance(x2, y2, x, y);\n  }\n  return pointToLine(x1, y1, x2, y2, x, y);\n}\nfunction pointToLine(x1, y1, x2, y2, x, y) {\n  var d = [x2 - x1, y2 - y1];\n  // 如果端点相等，则判定点到点的距离\n  if (vec2.exactEquals(d, [0, 0])) {\n    return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  }\n  var u = [-d[1], d[0]];\n  vec2.normalize(u, u);\n  var a = [x - x1, y - y1];\n  return Math.abs(vec2.dot(a, u));\n}\nfunction tangentAngle$3(x1, y1, x2, y2) {\n  return Math.atan2(y2 - y1, x2 - x1);\n}\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;\n}\nfunction derivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));\n}\nfunction extrema$1(p0, p1, p2, p3) {\n  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n  var b = 6 * p0 - 12 * p1 + 6 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var extremas = [];\n  var t1;\n  var t2;\n  var discSqrt;\n  if (isNumberEqual(a, 0)) {\n    if (!isNumberEqual(b, 0)) {\n      t1 = -c / b;\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n    if (isNumberEqual(disc, 0)) {\n      extremas.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n      if (t2 >= 0 && t2 <= 1) {\n        extremas.push(t2);\n      }\n    }\n  }\n  return extremas;\n}\n\n// 分割贝塞尔曲线\nfunction divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  // 划分点\n  var xt = cubicAt(x1, x2, x3, x4, t);\n  var yt = cubicAt(y1, y2, y3, y4, t);\n  // 计算两点之间的差值点\n  var c1 = pointAt$3(x1, y1, x2, y2, t);\n  var c2 = pointAt$3(x2, y2, x3, y3, t);\n  var c3 = pointAt$3(x3, y3, x4, y4, t);\n  var c12 = pointAt$3(c1.x, c1.y, c2.x, c2.y, t);\n  var c23 = pointAt$3(c2.x, c2.y, c3.x, c3.y, t);\n  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];\n}\n\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {\n  if (iterationCount === 0) {\n    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n  }\n  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n  var left = [].concat(_toConsumableArray(cubics[0]), [iterationCount - 1]);\n  var right = [].concat(_toConsumableArray(cubics[1]), [iterationCount - 1]);\n  return cubicLength.apply(void 0, _toConsumableArray(left)) + cubicLength.apply(void 0, _toConsumableArray(right));\n}\nfunction box$3(x1, y1, x2, y2, x3, y3, x4, y4) {\n  var xArr = [x1, x4];\n  var yArr = [y1, y4];\n  var xExtrema = extrema$1(x1, x2, x3, x4);\n  var yExtrema = extrema$1(y1, y2, y3, y4);\n  for (var i = 0; i < xExtrema.length; i++) {\n    xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n  }\n  for (var _i = 0; _i < yExtrema.length; _i++) {\n    yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[_i]));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nfunction length$3(x1, y1, x2, y2, x3, y3, x4, y4) {\n  // 迭代三次，划分成 8 段求长度\n  return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n}\nfunction nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\n  return nearestPoint$2([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);\n}\nfunction pointDistance$3(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {\n  var point = nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n  return distance(point.x, point.y, x0, y0);\n}\nfunction pointAt$2(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  return {\n    x: cubicAt(x1, x2, x3, x4, t),\n    y: cubicAt(y1, y2, y3, y4, t)\n  };\n}\nfunction tangentAngle$2(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  var dx = derivativeAt(x1, x2, x3, x4, t);\n  var dy = derivativeAt(y1, y2, y3, y4, t);\n  return piMod(Math.atan2(dy, dx));\n}\n\nfunction analyzePoints(points) {\n  // 计算每段的长度和总的长度\n  var totalLength = 0;\n  var segments = [];\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    var length = distance(from[0], from[1], to[0], to[1]);\n    var seg = {\n      from: from,\n      to: to,\n      length: length\n    };\n    segments.push(seg);\n    totalLength += length;\n  }\n  return {\n    segments: segments,\n    totalLength: totalLength\n  };\n}\nfunction lengthOfSegment(points) {\n  if (points.length < 2) {\n    return 0;\n  }\n  var totalLength = 0;\n  for (var i = 0; i < points.length - 1; i++) {\n    var from = points[i];\n    var to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nfunction pointAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  var _analyzePoints = analyzePoints(points),\n    segments = _analyzePoints.segments,\n    totalLength = _analyzePoints.totalLength;\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1]\n    };\n  }\n  // 计算比例\n  var startRatio = 0;\n  var point = null;\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n      to = seg.to;\n    var currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      var localRatio = (t - startRatio) / currentRatio;\n      point = pointAt$3(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nfunction angleAtSegments(points, t) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  var _analyzePoints2 = analyzePoints(points),\n    segments = _analyzePoints2.segments,\n    totalLength = _analyzePoints2.totalLength;\n  // 计算比例\n  var startRatio = 0;\n  var angle = 0;\n  for (var i = 0; i < segments.length; i++) {\n    var seg = segments[i];\n    var from = seg.from,\n      to = seg.to;\n    var currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\nfunction distanceAtSegment(points, x, y) {\n  var minDistance = Infinity;\n  for (var i = 0; i < points.length - 1; i++) {\n    var point = points[i];\n    var nextPoint = points[i + 1];\n    var _distance = pointDistance$4(point[0], point[1], nextPoint[0], nextPoint[1], x, y);\n    if (_distance < minDistance) {\n      minDistance = _distance;\n    }\n  }\n  return minDistance;\n}\n\nfunction box$2(points) {\n  var xArr = [];\n  var yArr = [];\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nfunction length$2(points) {\n  return lengthOfSegment(points);\n}\nfunction pointAt$1(points, t) {\n  return pointAtSegments(points, t);\n}\nfunction pointDistance$2(points, x, y) {\n  return distanceAtSegment(points, x, y);\n}\nfunction tangentAngle$1(points, t) {\n  return angleAtSegments(points, t);\n}\n\nfunction getAllPoints(points) {\n  var tmp = points.slice(0);\n  if (points.length) {\n    tmp.push(points[0]);\n  }\n  return tmp;\n}\nfunction box$1(points) {\n  return box$2(points);\n}\nfunction length$1(points) {\n  return lengthOfSegment(getAllPoints(points));\n}\nfunction pointAt(points, t) {\n  return pointAtSegments(getAllPoints(points), t);\n}\nfunction pointDistance$1(points, x, y) {\n  return distanceAtSegment(getAllPoints(points), x, y);\n}\nfunction tangentAngle(points, t) {\n  return angleAtSegments(getAllPoints(points), t);\n}\n\n// 差值公式\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n\n// 求极值\nfunction extrema(p0, p1, p2) {\n  var a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  var rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\n\n// 分割贝塞尔曲线\nfunction divideQuadratic(x1, y1, x2, y2, x3, y3, t) {\n  // 划分点\n  var xt = quadraticAt(x1, x2, x3, t);\n  var yt = quadraticAt(y1, y2, y3, t);\n\n  // 分割的第一条曲线的控制点\n  var controlPoint1 = pointAt$3(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  var controlPoint2 = pointAt$3(x2, y2, x3, y3, t);\n  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];\n}\n\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {\n  if (iterationCount === 0) {\n    return (distance(x1, y1, x2, y2) + distance(x2, y2, x3, y3) + distance(x1, y1, x3, y3)) / 2;\n  }\n  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  var left = quadratics[0];\n  var right = quadratics[1];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength.apply(void 0, _toConsumableArray(left)) + quadraticLength.apply(void 0, _toConsumableArray(right));\n}\nfunction box(x1, y1, x2, y2, x3, y3) {\n  var xExtrema = extrema(x1, x2, x3)[0];\n  var yExtrema = extrema(y1, y2, y3)[0];\n  // 控制点不加入 box 的计算\n  var xArr = [x1, x3];\n  var yArr = [y1, y3];\n  if (xExtrema !== undefined) {\n    xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n  }\n  if (yExtrema !== undefined) {\n    yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nfunction length(x1, y1, x2, y2, x3, y3) {\n  return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n}\nfunction nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0) {\n  return nearestPoint$2([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n}\nfunction pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {\n  var point = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n  return distance(point.x, point.y, x0, y0);\n}\n\nexport { box$5 as arcBox, nearestPoint$3 as arcNearestPoint, tangentAngle$4 as arcTangentAngle, box$3 as cubicBox, length$3 as cubicLength, nearestPoint$1 as cubicNearestPoint, pointAt$2 as cubicPointAt, pointDistance$3 as cubicPointDistance, tangentAngle$2 as cubicTangentAngle, distance, box$4 as lineBox, length$4 as lineLength, pointAt$3 as linePointAt, pointDistance$4 as linePointDistance, pointToLine as linePointToLine, tangentAngle$3 as lineTangentAngle, box$1 as polygonBox, length$1 as polygonLength, pointAt as polygonPointAt, pointDistance$1 as polygonPointDistance, tangentAngle as polygonTangentAngle, box$2 as polylineBox, length$2 as polylineLength, pointAt$1 as polylinePointAt, pointDistance$2 as polylinePointDistance, tangentAngle$1 as polylineTangentAngle, box as quadBox, length as quadLength, nearestPoint as quadNearestPoint, pointDistance as quadPointDistance };\n//# sourceMappingURL=index.esm.js.map\n","import type {\n  CircleStyleProps,\n  DisplayObject,\n  ParsedCircleStyleProps,\n  Point,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { distance } from '@antv/g-math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<CircleStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    cx = 0,\n    cy = 0,\n    r,\n    fill,\n    stroke,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedCircleStyleProps;\n  const halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;\n  const absDistance = distance(cx, cy, position.x, position.y);\n\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  if ((hasFill && hasStroke) || isClipPath) {\n    return absDistance <= r + halfLineWidth;\n  }\n  if (hasFill) {\n    return absDistance <= r;\n  }\n  if (hasStroke) {\n    return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n  }\n  return false;\n}\n","import type {\n  DisplayObject,\n  EllipseStyleProps,\n  ParsedEllipseStyleProps,\n  Point,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\n\nfunction ellipseDistance(\n  squareX: number,\n  squareY: number,\n  rx: number,\n  ry: number,\n) {\n  return squareX / (rx * rx) + squareY / (ry * ry);\n}\n\nexport function isPointInPath(\n  displayObject: DisplayObject<EllipseStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    cx = 0,\n    cy = 0,\n    rx,\n    ry,\n    fill,\n    stroke,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedEllipseStyleProps;\n\n  const { x, y } = position;\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  const halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;\n  const squareX = (x - cx) * (x - cx);\n  const squareY = (y - cy) * (y - cy);\n  // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n  if ((hasFill && hasStroke) || isClipPath) {\n    return (\n      ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=\n      1\n    );\n  }\n  if (hasFill) {\n    return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n  }\n  if (hasStroke) {\n    return (\n      ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >=\n        1 &&\n      ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <=\n        1\n    );\n  }\n  return false;\n}\n","import { distance, linePointToLine } from '@antv/g-math';\n\nexport function inBox(\n  minX: number,\n  minY: number,\n  width: number,\n  height: number,\n  x: number,\n  y: number,\n) {\n  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;\n}\n\nexport function inRect(\n  minX: number,\n  minY: number,\n  width: number,\n  height: number,\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const halfWidth = lineWidth / 2;\n  // 将四个边看做矩形来检测，比边的检测算法要快\n  return (\n    inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 上边\n    inBox(\n      minX + width - halfWidth,\n      minY - halfWidth,\n      lineWidth,\n      height,\n      x,\n      y,\n    ) || // 右边\n    inBox(\n      minX + halfWidth,\n      minY + height - halfWidth,\n      width,\n      lineWidth,\n      x,\n      y,\n    ) || // 下边\n    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y)\n  ); // 左边\n}\n\nexport function inArc(\n  cx: number,\n  cy: number,\n  r: number,\n  startAngle: number,\n  endAngle: number,\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); // 转换到 0 - 2 * Math.PI 之间\n  // if (angle < startAngle || angle > endAngle) {\n  //   return false;\n  // }\n  const point = {\n    x: cx + r * Math.cos(angle),\n    y: cy + r * Math.sin(angle),\n  };\n\n  return distance(point.x, point.y, x, y) <= lineWidth / 2;\n}\n\nexport function inLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const minX = Math.min(x1, x2);\n  const maxX = Math.max(x1, x2);\n  const minY = Math.min(y1, y2);\n  const maxY = Math.max(y1, y2);\n  const halfWidth = lineWidth / 2;\n  // 因为目前的方案是计算点到直线的距离，而有可能会在延长线上，所以要先判断是否在包围盒内\n  // 这种方案会在水平或者竖直的情况下载线的延长线上有半 lineWidth 的误差\n  if (\n    !(\n      x >= minX - halfWidth &&\n      x <= maxX + halfWidth &&\n      y >= minY - halfWidth &&\n      y <= maxY + halfWidth\n    )\n  ) {\n    return false;\n  }\n  // 因为已经计算了包围盒，所以仅需要计算到直线的距离即可，可以显著提升性能\n  return linePointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;\n}\n\nexport function inPolyline(\n  points: any[],\n  lineWidth: number,\n  x: number,\n  y: number,\n  isClose: boolean,\n) {\n  const count = points.length;\n  if (count < 2) {\n    return false;\n  }\n  for (let i = 0; i < count - 1; i++) {\n    const x1 = points[i][0];\n    const y1 = points[i][1];\n    const x2 = points[i + 1][0];\n    const y2 = points[i + 1][1];\n\n    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  // 如果封闭，则计算起始点和结束点的边\n  if (isClose) {\n    const first = points[0];\n    const last = points[count - 1];\n    if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// 多边形的射线检测，参考：https://blog.csdn.net/WilliamSun0122/article/details/77994526\nconst tolerance = 1e-6;\n// 三态函数，判断两个double在eps精度下的大小关系\nfunction dcmp(x: number) {\n  if (Math.abs(x) < tolerance) {\n    return 0;\n  }\n\n  return x < 0 ? -1 : 1;\n}\n\n// 判断点Q是否在p1和p2的线段上\nfunction onSegment(p1: any, p2: any, q: any) {\n  if (\n    (q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) &&\n    Math.min(p1[0], p2[0]) <= q[0] &&\n    q[0] <= Math.max(p1[0], p2[0]) &&\n    Math.min(p1[1], p2[1]) <= q[1] &&\n    q[1] <= Math.max(p1[1], p2[1])\n  ) {\n    return true;\n  }\n  return false;\n}\n\n// 判断点P在多边形内-射线法\nexport function inPolygon(points: any[], x: number, y: number) {\n  let isHit = false;\n  const n = points.length;\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    const p2 = points[(i + 1) % n];\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    }\n    // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n    if (\n      dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 &&\n      dcmp(x - ((y - p1[1]) * (p1[0] - p2[0])) / (p1[1] - p2[1]) - p1[0]) < 0\n    ) {\n      isHit = !isHit;\n    }\n  }\n  return isHit;\n}\nexport function inPolygons(polygons: any[], x: number, y: number): boolean {\n  let isHit = false;\n  for (let i = 0; i < polygons.length; i++) {\n    const points = polygons[i];\n    isHit = inPolygon(points, x, y);\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\n","import type {\n  DisplayObject,\n  LineStyleProps,\n  ParsedLineStyleProps,\n  Point,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { inLine } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<LineStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    x1,\n    y1,\n    x2,\n    y2,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    pointerEvents = 'auto',\n    fill,\n    stroke,\n  } = displayObject.parsedStyle as ParsedLineStyleProps;\n\n  const [, hasStroke] = isFillOrStrokeAffected(pointerEvents, fill, stroke);\n\n  if ((!hasStroke && !isClipPath) || !lineWidth) {\n    return false;\n  }\n\n  return inLine(\n    x1,\n    y1,\n    x2,\n    y2,\n    lineWidth + increasedLineWidthForHitTesting,\n    position.x,\n    position.y,\n  );\n}\n","import type {\n  DisplayObject,\n  GlobalRuntime,\n  ParsedPathStyleProps,\n  Path,\n  PathSegment,\n  PathStyleProps,\n  Point,\n  RenderingPluginContext,\n} from '@antv/g-lite';\nimport {\n  getOrCalculatePathTotalLength,\n  isFillOrStrokeAffected,\n} from '@antv/g-lite';\nimport { cubicPointDistance, quadPointDistance } from '@antv/g-math';\nimport { arcToCubic } from '@antv/util';\nimport { inBox, inLine, inPolygons } from './utils/math';\n\n// TODO: replace it with method in @antv/util\nfunction isPointInStroke(\n  segments: PathSegment[],\n  lineWidth: number,\n  px: number,\n  py: number,\n  length: number,\n) {\n  let isHit = false;\n  const halfWidth = lineWidth / 2;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const { currentPoint, params, prePoint, box } = segment;\n    // 如果在前面已经生成过包围盒，直接按照包围盒计算\n    if (\n      box &&\n      !inBox(\n        box.x - halfWidth,\n        box.y - halfWidth,\n        box.width + lineWidth,\n        box.height + lineWidth,\n        px,\n        py,\n      )\n    ) {\n      continue;\n    }\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(\n          prePoint[0],\n          prePoint[1],\n          currentPoint[0],\n          currentPoint[1],\n          lineWidth,\n          px,\n          py,\n        );\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'Q':\n        const qDistance = quadPointDistance(\n          prePoint[0],\n          prePoint[1],\n          params[1],\n          params[2],\n          params[3],\n          params[4],\n          px,\n          py,\n        );\n        isHit = qDistance <= lineWidth / 2;\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'C':\n        const cDistance = cubicPointDistance(\n          prePoint[0], // 上一段结束位置, 即 C 的起始点\n          prePoint[1],\n          params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n          params[2],\n          params[3],\n          params[4],\n          params[5],\n          params[6],\n          px,\n          py,\n          length,\n        );\n        isHit = cDistance <= lineWidth / 2;\n        if (isHit) {\n          return true;\n        }\n        break;\n      case 'A':\n        // cache conversion result\n        if (!segment.cubicParams) {\n          segment.cubicParams = arcToCubic(\n            prePoint[0],\n            prePoint[1],\n            params[1],\n            params[2],\n            params[3],\n            params[4],\n            params[5],\n            params[6],\n            params[7],\n            undefined,\n          ) as [number, number, number, number, number, number];\n        }\n\n        const args = segment.cubicParams;\n\n        // fixArc\n        let prePointInCubic = prePoint;\n        for (let i = 0; i < args.length; i += 6) {\n          const cDistance = cubicPointDistance(\n            prePointInCubic[0], // 上一段结束位置, 即 C 的起始点\n            prePointInCubic[1],\n            args[i],\n            args[i + 1],\n            args[i + 2],\n            args[i + 3],\n            args[i + 4],\n            args[i + 5],\n            px,\n            py,\n            length,\n          );\n          prePointInCubic = [args[i + 4], args[i + 5]];\n          isHit = cDistance <= lineWidth / 2;\n\n          if (isHit) {\n            return true;\n          }\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return isHit;\n}\n\nexport function isPointInPath(\n  displayObject: DisplayObject<PathStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<PathStyleProps>,\n    position: Point,\n  ) => boolean,\n  renderingPluginContext: RenderingPluginContext,\n  runtime: GlobalRuntime,\n): boolean {\n  const {\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    stroke,\n    fill,\n    d,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedPathStyleProps;\n\n  const { segments, hasArc, polylines, polygons } = d;\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    // Only a closed path can be filled.\n    polygons?.length && fill,\n    stroke,\n  );\n\n  const totalLength = getOrCalculatePathTotalLength(displayObject as Path);\n\n  let isHit = false;\n\n  if (hasFill || isClipPath) {\n    if (hasArc) {\n      // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n      isHit = isPointInPath(displayObject, position);\n    } else {\n      // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n      isHit =\n        inPolygons(polygons, position.x, position.y) ||\n        inPolygons(polylines, position.x, position.y);\n    }\n    return isHit;\n  }\n  if (hasStroke || isClipPath) {\n    isHit = isPointInStroke(\n      segments,\n      lineWidth + increasedLineWidthForHitTesting,\n      position.x,\n      position.y,\n      totalLength,\n    );\n  }\n\n  return isHit;\n}\n","import type {\n  DisplayObject,\n  ParsedPolygonStyleProps,\n  Point,\n  PolylineStyleProps,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { inPolygon, inPolyline } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<PolylineStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    stroke,\n    fill,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    points,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedPolygonStyleProps;\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  let isHit = false;\n  if (hasStroke || isClipPath) {\n    isHit = inPolyline(\n      points.points,\n      lineWidth + increasedLineWidthForHitTesting,\n      position.x,\n      position.y,\n      true,\n    );\n  }\n  if (!isHit && (hasFill || isClipPath)) {\n    isHit = inPolygon(points.points, position.x, position.y);\n  }\n  return isHit;\n}\n","import type {\n  DisplayObject,\n  ParsedPolylineStyleProps,\n  Point,\n  PolylineStyleProps,\n} from '@antv/g-lite';\nimport { isFillOrStrokeAffected } from '@antv/g-lite';\nimport { inPolyline } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<PolylineStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n): boolean {\n  const {\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    points,\n    pointerEvents = 'auto',\n    fill,\n    stroke,\n  } = displayObject.parsedStyle as ParsedPolylineStyleProps;\n  const [, hasStroke] = isFillOrStrokeAffected(pointerEvents, fill, stroke);\n\n  if ((!hasStroke && !isClipPath) || !lineWidth) {\n    return false;\n  }\n\n  return inPolyline(\n    points.points,\n    lineWidth + increasedLineWidthForHitTesting,\n    position.x,\n    position.y,\n    false,\n  );\n}\n","import type {\n  DisplayObject,\n  ParsedRectStyleProps,\n  Point,\n  RectStyleProps,\n} from '@antv/g-lite';\nimport { GlobalRuntime, isFillOrStrokeAffected } from '@antv/g-lite';\nimport { clamp } from '@antv/util';\nimport { inArc, inBox, inLine, inRect } from './utils/math';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<RectStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<RectStyleProps>,\n    position: Point,\n  ) => boolean,\n  runtime: GlobalRuntime,\n): boolean {\n  const {\n    radius,\n    fill,\n    stroke,\n    lineWidth = 1,\n    increasedLineWidthForHitTesting = 0,\n    x = 0,\n    y = 0,\n    width,\n    height,\n    pointerEvents = 'auto',\n  } = displayObject.parsedStyle as ParsedRectStyleProps;\n\n  const [hasFill, hasStroke] = isFillOrStrokeAffected(\n    pointerEvents,\n    fill,\n    stroke,\n  );\n\n  const hasRadius = radius && radius.some((r) => r !== 0);\n\n  const lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;\n\n  // 无圆角时的策略\n  if (!hasRadius) {\n    const halfWidth = lineWidthForHitTesting / 2;\n    // 同时填充和带有边框\n    if ((hasFill && hasStroke) || isClipPath) {\n      return inBox(\n        x - halfWidth,\n        y - halfWidth,\n        width + halfWidth,\n        height + halfWidth,\n        position.x,\n        position.y,\n      );\n    }\n    // 仅填充\n    if (hasFill) {\n      return inBox(x, y, width, height, position.x, position.y);\n    }\n    if (hasStroke) {\n      return inRect(\n        x,\n        y,\n        width,\n        height,\n        lineWidthForHitTesting,\n        position.x,\n        position.y,\n      );\n    }\n  } else {\n    let isHit = false;\n    if (hasStroke || isClipPath) {\n      isHit = inRectWithRadius(\n        x,\n        y,\n        width,\n        height,\n        radius.map((r) =>\n          clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2)),\n        ) as [number, number, number, number],\n        lineWidthForHitTesting,\n        position.x,\n        position.y,\n      );\n    }\n    // 仅填充时带有圆角的矩形直接通过图形拾取\n    // 以后可以改成纯数学的近似拾取，将圆弧切割成多边形\n    if (!isHit && (hasFill || isClipPath)) {\n      isHit = isPointInPath(displayObject, position);\n    }\n    return isHit;\n  }\n\n  return false;\n}\n\nfunction inRectWithRadius(\n  minX: number,\n  minY: number,\n  width: number,\n  height: number,\n  radiusArray: [number, number, number, number],\n  lineWidth: number,\n  x: number,\n  y: number,\n) {\n  const [tlr, trr, brr, blr] = radiusArray;\n  return (\n    inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) ||\n    inLine(\n      minX + width,\n      minY + trr,\n      minX + width,\n      minY + height - brr,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inLine(\n      minX + width - brr,\n      minY + height,\n      minX + blr,\n      minY + height,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) ||\n    inArc(\n      minX + width - trr,\n      minY + trr,\n      trr,\n      1.5 * Math.PI,\n      2 * Math.PI,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inArc(\n      minX + width - brr,\n      minY + height - brr,\n      brr,\n      0,\n      0.5 * Math.PI,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inArc(\n      minX + blr,\n      minY + height - blr,\n      blr,\n      0.5 * Math.PI,\n      Math.PI,\n      lineWidth,\n      x,\n      y,\n    ) ||\n    inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y)\n  );\n}\n","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nexport { _objectSpread2 as default };","import {\n  DisplayObject,\n  ParsedImageStyleProps,\n  Point,\n  ImageStyleProps,\n  Shape,\n  RenderingPluginContext,\n  GlobalRuntime,\n} from '@antv/g-lite';\nimport { StyleRenderer } from '@antv/g-plugin-canvas-renderer';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<ImageStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<ImageStyleProps>,\n    position: Point,\n  ) => boolean,\n  renderingPluginContext: RenderingPluginContext,\n  runtime: GlobalRuntime,\n): boolean {\n  const {\n    pointerEvents = 'auto',\n    x = 0,\n    y = 0,\n    width,\n    height,\n  } = displayObject.parsedStyle as ParsedImageStyleProps;\n\n  if (pointerEvents === 'non-transparent-pixel') {\n    const { offscreenCanvas } = renderingPluginContext.config;\n    const canvas =\n      runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);\n    const context = runtime.offscreenCanvasCreator.getOrCreateContext(\n      offscreenCanvas,\n      {\n        willReadFrequently: true,\n      },\n    ) as CanvasRenderingContext2D;\n    canvas.width = width;\n    canvas.height = height;\n\n    (\n      (renderingPluginContext as any).defaultStyleRendererFactory as Record<\n        Shape,\n        StyleRenderer\n      >\n    )[Shape.IMAGE].render(\n      context,\n      { ...displayObject.parsedStyle, x: 0, y: 0 },\n      displayObject,\n      undefined,\n      undefined,\n      undefined,\n    );\n\n    const imagedata = context.getImageData(\n      position.x - x,\n      position.y - y,\n      1,\n      1,\n    ).data;\n    return imagedata.every((component) => component !== 0);\n  }\n\n  return true;\n}\n","import type { DisplayObject, Point, TextStyleProps } from '@antv/g-lite';\n\nexport function isPointInPath(\n  displayObject: DisplayObject<TextStyleProps>,\n  position: Point,\n  isClipPath: boolean,\n  isPointInPath: (\n    displayObject: DisplayObject<TextStyleProps>,\n    position: Point,\n  ) => boolean,\n): boolean {\n  const bounds = displayObject.getGeometryBounds();\n\n  // @see https://stackoverflow.com/questions/28706989/how-do-i-check-if-a-mouse-click-is-inside-a-rotated-text-on-the-html5-canvas-in\n  return (\n    position.x >= bounds.min[0] &&\n    position.y >= bounds.min[1] &&\n    position.x <= bounds.max[0] &&\n    position.y <= bounds.max[1]\n  );\n}\n","import { AbstractRendererPlugin, Shape } from '@antv/g-lite';\nimport type { PointInPathPicker } from './CanvasPickerPlugin';\nimport { CanvasPickerPlugin } from './CanvasPickerPlugin';\nimport { isPointInPath as CirclePicker } from './Circle';\nimport { isPointInPath as EllipsePicker } from './Ellipse';\nimport { isPointInPath as LinePicker } from './Line';\nimport { isPointInPath as PathPicker } from './Path';\nimport { isPointInPath as PolygonPicker } from './Polygon';\nimport { isPointInPath as PolylinePicker } from './Polyline';\nimport { isPointInPath as RectPicker } from './Rect';\nimport { isPointInPath as ImagePicker } from './Image';\nimport { isPointInPath as TextPicker } from './Text';\n\nexport class Plugin extends AbstractRendererPlugin {\n  name = 'canvas-picker';\n  init(): void {\n    const pointInPathPickerFactory: Record<Shape, PointInPathPicker<any>> = {\n      [Shape.CIRCLE]: CirclePicker,\n      [Shape.ELLIPSE]: EllipsePicker,\n      [Shape.RECT]: RectPicker,\n      [Shape.LINE]: LinePicker,\n      [Shape.POLYLINE]: PolylinePicker,\n      [Shape.POLYGON]: PolygonPicker,\n      [Shape.PATH]: PathPicker,\n      [Shape.TEXT]: TextPicker,\n      [Shape.GROUP]: null,\n      [Shape.IMAGE]: ImagePicker,\n      [Shape.HTML]: null,\n      [Shape.MESH]: null,\n    };\n\n    // @ts-ignore\n    this.context.pointInPathPickerFactory = pointInPathPickerFactory;\n\n    this.addRenderingPlugin(new CanvasPickerPlugin());\n  }\n  destroy(): void {\n    // @ts-ignore\n    delete this.context.pointInPathPickerFactory;\n    this.removeAllRenderingPlugins();\n  }\n}\n","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nfunction _callSuper(t, o, e) {\n  return o = getPrototypeOf(o), possibleConstructorReturn(t, isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nexport { _callSuper as default };","import setPrototypeOf from \"./setPrototypeOf.js\";\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && setPrototypeOf(t, e);\n}\nexport { _inherits as default };"],"names":["_typeof","o","Symbol","iterator","constructor","prototype","toPropertyKey","t","i","r","e","toPrimitive","call","TypeError","String","Number","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","_classCallCheck","a","n","_defineProperties","length","key","_createClass","_getPrototypeOf","setPrototypeOf","getPrototypeOf","bind","__proto__","_isNativeReflectConstruct","Boolean","valueOf","Reflect","construct","_possibleConstructorReturn","ReferenceError","assertThisInitialized","_setPrototypeOf","_arrayLikeToArray","Array","_unsupportedIterableToArray","arrayLikeToArray","toString","slice","name","from","test","_regeneratorRuntime","hasOwnProperty","c","asyncIterator","u","toStringTag","define","wrap","create","Generator","Context","makeInvokeMethod","tryCatch","type","arg","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","this","d","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","displayName","isGeneratorFunction","mark","awrap","async","Promise","keys","reverse","pop","prev","charAt","stop","rval","handle","complete","finish","catch","delegateYield","asyncGeneratorStep","ARRAY_TYPE","Float32Array","out","glMatrix.ARRAY_TYPE","set","x","z","Math","hypot","arguments","sqrt","vec","tmpVec3a","vec3","tmpVec3b","tmpVec3c","tmpMat4","CanvasPickerPlugin","_this","isHit","displayObject","position","worldTransform","isClipPath","pick","context","pointInPathPickerFactory","nodeName","invertWorldMat","a00","a01","a02","a03","a10","a11","a12","a13","a20","a21","a22","a23","a30","a31","a32","a33","b00","b01","b02","b03","b04","b05","b06","b07","b08","b09","b10","b11","det","mat4","localPosition","m","w","Point","isPointInPath","runtime","offscreenCanvasCreator","getOrCreateContext","config","offscreenCanvas","generatePath","pathGeneratorFactory","beginPath","parsedStyle","closePath","_renderingContext$roo","_this2","renderingService","renderingContext","document","root","ownerDocument","hooks","tapPromise","tag","_ref","_callee","result","_context","apply","_next","_throw","_x","pickSync","tap","_step","topmost","_result$position","pickedDisplayObjects","_iterator","isArray","unsupportedIterableToArray","_n","F","_createForOfIteratorHelper","elementsFromBBox","getWorldTransform","clipped","findClosestClipPathTarget","clipPath","picked","err","_slicedToArray","arrayWithHoles","iterableToArrayLimit","nonIterableRest","_toConsumableArray","arrayWithoutHoles","iterableToArray","nonIterableSpread","clamp$1","min","max","rotateVector","rad","cos","sin","arcToCubic","X1","Y1","RX","RY","angle","LAF","SF","X2","Y2","recursive","xy","f1","f2","cx","cy","x1","y1","rx","ry","x2","y2","d120","PI","res","rx2","ry2","k","abs","asin","df","f2old","x2old","y2old","c1","s1","c2","s2","tan","hx","hy","m1","m2","m3","m4","concat","newres","ii","distance","dx","dy","b","len","_ref$cx","_ref$cy","fill","stroke","_ref$lineWidth","lineWidth","_ref$increasedLineWid","increasedLineWidthForHitTesting","_ref$pointerEvents","pointerEvents","halfLineWidth","absDistance","_isFillOrStrokeAffect2","isFillOrStrokeAffected","hasFill","hasStroke","ellipseDistance","squareX","squareY","halfLineWith","inBox","minX","minY","width","height","inArc","startAngle","endAngle","atan2","point","inLine","halfWidth","linePointToLine","inPolyline","points","isClose","count","first","last","tolerance","dcmp","onSegment","p1","p2","q","inPolygon","inPolygons","polygons","renderingPluginContext","segments","hasArc","polylines","totalLength","getOrCalculatePathTotalLength","px","py","segment","currentPoint","params","prePoint","box","command","quadPointDistance","cubicPointDistance","cubicParams","undefined","args","prePointInCubic","cDistance","isPointInStroke","radius","_ref$x","_ref$y","lineWidthForHitTesting","some","radiusArray","_radiusArray","tlr","trr","brr","blr","inRectWithRadius","map","clamp","inRect","ownKeys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","_objectSpread2","getOwnPropertyDescriptors","defineProperties","canvas","getOrCreateCanvas","willReadFrequently","defaultStyleRendererFactory","Shape","IMAGE","render","_objectSpread","getImageData","data","every","component","bounds","getGeometryBounds","Plugin","_AbstractRendererPlug","_len","_key","possibleConstructorReturn","isNativeReflectConstruct","_inherits","_pointInPathPickerFac","CIRCLE","CirclePicker","ELLIPSE","EllipsePicker","RECT","RectPicker","LINE","LinePicker","POLYLINE","PolylinePicker","POLYGON","PolygonPicker","PATH","PathPicker","TEXT","TextPicker","GROUP","ImagePicker","HTML","MESH","addRenderingPlugin","removeAllRenderingPlugins","AbstractRendererPlugin"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,23,24,25,26,27,28,29,30,31,41,45,46]}