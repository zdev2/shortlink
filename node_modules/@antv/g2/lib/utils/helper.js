"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepAssign = exports.isUnset = exports.isStrictObject = exports.maybePercentage = exports.omitPrefixObject = exports.filterPrefixObject = exports.prefixObject = exports.maybeSubObject = exports.subObject = exports.appendTransform = exports.useMemo = exports.random = exports.defined = exports.copyAttributes = exports.error = exports.capitalizeFirst = exports.composeAsync = exports.compose = exports.identity = void 0;
const util_1 = require("@antv/util");
function identity(x) {
    return x;
}
exports.identity = identity;
/**
 * Composes functions from left to right.
 */
function compose(fns) {
    return fns.reduce((composed, fn) => (x, ...args) => fn(composed(x, ...args), ...args), identity);
}
exports.compose = compose;
/**
 * Composes single-argument async functions from left to right.
 */
function composeAsync(fns) {
    return fns.reduce((composed, fn) => (x) => __awaiter(this, void 0, void 0, function* () {
        const value = yield composed(x);
        return fn(value);
    }), identity);
}
exports.composeAsync = composeAsync;
function capitalizeFirst(str) {
    return str.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
exports.capitalizeFirst = capitalizeFirst;
function error(message = '') {
    throw new Error(message);
}
exports.error = error;
function copyAttributes(target, source) {
    const { attributes } = source;
    const exclude = new Set(['id', 'className']);
    for (const [key, value] of Object.entries(attributes)) {
        if (!exclude.has(key)) {
            target.attr(key, value);
        }
    }
}
exports.copyAttributes = copyAttributes;
function defined(x) {
    return x !== undefined && x !== null && !Number.isNaN(x);
}
exports.defined = defined;
function random(a, b) {
    return a + (b - a) * Math.random();
}
exports.random = random;
function useMemo(compute) {
    const map = new Map();
    return (key) => {
        if (map.has(key))
            return map.get(key);
        const value = compute(key);
        map.set(key, value);
        return value;
    };
}
exports.useMemo = useMemo;
function appendTransform(node, transform) {
    const { transform: preTransform } = node.style;
    const unset = (d) => d === 'none' || d === undefined;
    const prefix = unset(preTransform) ? '' : preTransform;
    node.style.transform = `${prefix} ${transform}`.trimStart();
}
exports.appendTransform = appendTransform;
function subObject(obj, prefix) {
    return maybeSubObject(obj, prefix) || {};
}
exports.subObject = subObject;
function maybeSubObject(obj, prefix) {
    const entries = Object.entries(obj || {})
        .filter(([key]) => key.startsWith(prefix))
        .map(([key, value]) => [(0, util_1.lowerFirst)(key.replace(prefix, '').trim()), value])
        .filter(([key]) => !!key);
    return entries.length === 0 ? null : Object.fromEntries(entries);
}
exports.maybeSubObject = maybeSubObject;
function prefixObject(obj, prefix) {
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => {
        return [`${prefix}${(0, util_1.upperFirst)(key)}`, value];
    }));
}
exports.prefixObject = prefixObject;
function filterPrefixObject(obj, prefix) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p) => key.startsWith(p))));
}
exports.filterPrefixObject = filterPrefixObject;
function omitPrefixObject(obj, ...prefixes) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes.every((prefix) => !key.startsWith(prefix))));
}
exports.omitPrefixObject = omitPrefixObject;
function maybePercentage(x, size) {
    if (x === undefined)
        return null;
    if (typeof x === 'number')
        return x;
    const px = +x.replace('%', '');
    return Number.isNaN(px) ? null : (px / 100) * size;
}
exports.maybePercentage = maybePercentage;
function isStrictObject(d) {
    return (typeof d === 'object' &&
        !(d instanceof Date) &&
        d !== null &&
        !Array.isArray(d));
}
exports.isStrictObject = isStrictObject;
function isUnset(value) {
    return value === null || value === false;
}
exports.isUnset = isUnset;
function deepAssign(dist, src, maxLevel = 5, level = 0) {
    if (level >= maxLevel)
        return;
    for (const key of Object.keys(src)) {
        const value = src[key];
        if (!(0, util_1.isPlainObject)(value) || !(0, util_1.isPlainObject)(dist[key])) {
            dist[key] = value;
        }
        else {
            deepAssign(dist[key], value, maxLevel, level + 1);
        }
    }
    return dist;
}
exports.deepAssign = deepAssign;
//# sourceMappingURL=helper.js.map