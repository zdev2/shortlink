"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initializeData = exports.valueof = exports.field = exports.visualMark = exports.p = exports.createBandOffset = exports.bandWidth = exports.basePostInference = exports.basePreInference = exports.baseAnnotationChannels = exports.tooltipXd = exports.tooltip1d = exports.tooltip2d = exports.tooltip3d = exports.baseGeometryChannels = exports.baseChannels = void 0;
const transform_1 = require("../transform");
function baseChannels(options = {}) {
    const { shapes } = options;
    return [
        { name: 'color' },
        { name: 'opacity' },
        { name: 'shape', range: shapes },
        { name: 'enterType' },
        { name: 'enterDelay', scaleKey: 'enter' },
        { name: 'enterDuration', scaleKey: 'enter' },
        { name: 'enterEasing' },
        { name: 'key', scale: 'identity' },
        { name: 'groupKey', scale: 'identity' },
        { name: 'label', scale: 'identity' },
    ];
}
exports.baseChannels = baseChannels;
function baseGeometryChannels(options = {}) {
    return [...baseChannels(options), { name: 'title', scale: 'identity' }];
}
exports.baseGeometryChannels = baseGeometryChannels;
function tooltip3d() {
    return [
        { type: transform_1.MaybeTitle, channel: 'color' },
        { type: transform_1.MaybeTooltip, channel: ['x', 'y', 'z'] },
    ];
}
exports.tooltip3d = tooltip3d;
function tooltip2d() {
    return [
        { type: transform_1.MaybeTitle, channel: 'color' },
        { type: transform_1.MaybeTooltip, channel: ['x', 'y'] },
    ];
}
exports.tooltip2d = tooltip2d;
function tooltip1d() {
    return [
        { type: transform_1.MaybeTitle, channel: 'x' },
        { type: transform_1.MaybeTooltip, channel: ['y'] },
    ];
}
exports.tooltip1d = tooltip1d;
function tooltipXd() {
    return [
        { type: transform_1.MaybeTitle, channel: 'color' },
        { type: transform_1.MaybeTooltip, channel: ['position'] },
    ];
}
exports.tooltipXd = tooltipXd;
function baseAnnotationChannels(options = {}) {
    return baseChannels(options);
}
exports.baseAnnotationChannels = baseAnnotationChannels;
function basePreInference() {
    return [{ type: transform_1.MaybeKey }];
}
exports.basePreInference = basePreInference;
function basePostInference() {
    return [];
}
exports.basePostInference = basePostInference;
function bandWidth(scale, x) {
    return scale.getBandWidth(scale.invert(x));
}
exports.bandWidth = bandWidth;
function createBandOffset(scale, value, options = {}) {
    const { x: X, y: Y, series: S } = value;
    const { x, y, series } = scale;
    const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset, } = {}, } = options;
    const isBandX = !!(x === null || x === void 0 ? void 0 : x.getBandWidth);
    const isBandY = !!(y === null || y === void 0 ? void 0 : y.getBandWidth);
    const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
    if (!isBandX && !isBandY)
        return (d) => d;
    return (d, i) => {
        const widthX = isBandX ? bandWidth(x, X[i]) : 0;
        const widthY = isBandY ? bandWidth(y, Y[i]) : 0;
        const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;
        const offset = isSeries && S ? f() : 0;
        const [x0, y0] = d;
        return [x0 + bandOffsetX * widthX + offset, y0 + bandOffsetY * widthY];
    };
}
exports.createBandOffset = createBandOffset;
function p(d) {
    return parseFloat(d) / 100;
}
exports.p = p;
function visualMark(index, scale, value, coordinate) {
    const { x: X, y: Y } = value;
    const { innerWidth, innerHeight } = coordinate.getOptions();
    const P = Array.from(index, (i) => {
        const x0 = X[i];
        const y0 = Y[i];
        const x = typeof x0 === 'string' ? p(x0) * innerWidth : +x0;
        const y = typeof y0 === 'string' ? p(y0) * innerHeight : +y0;
        return [[x, y]];
    });
    return [index, P];
}
exports.visualMark = visualMark;
function field(encode) {
    return typeof encode === 'function' ? encode : (d) => d[encode];
}
exports.field = field;
function valueof(data, encode) {
    return Array.from(data, field(encode));
}
exports.valueof = valueof;
function initializeData(data, encode) {
    const { source = (d) => d.source, target = (d) => d.target, value = (d) => d.value, } = encode;
    const { links, nodes } = data;
    const LS = valueof(links, source);
    const LT = valueof(links, target);
    const LV = valueof(links, value);
    return {
        links: links.map((_, i) => ({
            target: LT[i],
            source: LS[i],
            value: LV[i],
        })),
        nodes: nodes || Array.from(new Set([...LS, ...LT]), (key) => ({ key })),
    };
}
exports.initializeData = initializeData;
//# sourceMappingURL=utils.js.map