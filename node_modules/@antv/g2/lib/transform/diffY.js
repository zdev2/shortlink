"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiffY = void 0;
const util_1 = require("@antv/util");
const helper_1 = require("./utils/helper");
const order_1 = require("./utils/order");
/**
 * The DiffY transform apply offset for y0 channels.
 * Keep y unchanged, set y1 = max(otherY), if y1 > y, remove the data.
 */
const DiffY = (options = {}) => {
    const { groupBy = 'x', series = true } = options;
    return (I, mark) => {
        const { encode } = mark;
        const [Y] = (0, helper_1.columnOf)(encode, 'y');
        const [_, fy1] = (0, helper_1.columnOf)(encode, 'y1');
        const [S] = series
            ? (0, helper_1.maybeColumnOf)(encode, 'series', 'color')
            : (0, helper_1.columnOf)(encode, 'color');
        // Create groups and apply specified order for each group.
        const groups = (0, order_1.createGroups)(groupBy, I, mark);
        // Only adjust Y1 channel.
        const newY1 = new Array(I.length);
        for (const G of groups) {
            const YG = G.map((i) => +Y[i]);
            // Process each series.
            for (let idx = 0; idx < G.length; idx++) {
                const i = G[idx];
                // Get the max Y of current group with current Y exclude.
                const max = Math.max(...YG.filter((_, _i) => _i !== idx));
                // Diff Y value.
                newY1[i] = +Y[i] > max ? max : Y[i];
            }
        }
        return [
            I,
            (0, util_1.deepMix)({}, mark, {
                encode: {
                    y1: (0, helper_1.column)(newY1, fy1),
                },
            }),
        ];
    };
};
exports.DiffY = DiffY;
exports.DiffY.props = {};
//# sourceMappingURL=diffY.js.map