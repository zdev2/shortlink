"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sort = void 0;
const util_1 = require("@antv/util");
const d3_array_1 = require("d3-array");
const helper_1 = require("./utils/helper");
function createReducer(channel, options, encode) {
    const { by = channel, reducer = 'max' } = options;
    const [V] = (0, helper_1.columnOf)(encode, by);
    if (typeof reducer === 'function')
        return (GI) => reducer(GI, V);
    if (reducer === 'max')
        return (GI) => (0, d3_array_1.max)(GI, (i) => +V[i]);
    if (reducer === 'min')
        return (GI) => (0, d3_array_1.min)(GI, (i) => +V[i]);
    if (reducer === 'sum')
        return (GI) => (0, d3_array_1.sum)(GI, (i) => +V[i]);
    if (reducer === 'median')
        return (GI) => (0, d3_array_1.median)(GI, (i) => +V[i]);
    if (reducer === 'mean')
        return (GI) => (0, d3_array_1.mean)(GI, (i) => +V[i]);
    if (reducer === 'first')
        return (GI) => V[GI[0]];
    if (reducer === 'last')
        return (GI) => V[GI[GI.length - 1]];
    throw new Error(`Unknown reducer: ${reducer}`);
}
function sortQuantitative(I, mark, options) {
    const { reverse, channel } = options;
    const { encode } = mark;
    const [V] = (0, helper_1.columnOf)(encode, channel);
    const sortedI = (0, d3_array_1.sort)(I, (i) => V[i]);
    if (reverse)
        sortedI.reverse();
    // const s = typeof slice === 'number' ? [0, slice] : slice;
    return [sortedI, mark];
}
// If domain is specified, only sort data in the domain.
function filterIndex(I, values, specifiedDomain) {
    if (!Array.isArray(specifiedDomain))
        return I;
    const domain = new Set(specifiedDomain);
    return I.filter((i) => domain.has(values[i]));
}
function sortOrdinal(I, mark, options) {
    var _a;
    const { reverse, slice, channel } = options, rest = __rest(options, ["reverse", "slice", "channel"]);
    const { encode, scale = {} } = mark;
    const domain = (_a = scale[channel]) === null || _a === void 0 ? void 0 : _a.domain;
    const [T] = (0, helper_1.columnOf)(encode, channel);
    const normalizeReducer = createReducer(channel, rest, encode);
    const SI = filterIndex(I, T, domain);
    const sortedDomain = (0, d3_array_1.groupSort)(SI, normalizeReducer, (i) => T[i]);
    if (reverse)
        sortedDomain.reverse();
    const s = typeof slice === 'number' ? [0, slice] : slice;
    const slicedDomain = slice ? sortedDomain.slice(...s) : sortedDomain;
    return [
        I,
        (0, util_1.deepMix)(mark, {
            scale: {
                [channel]: {
                    domain: slicedDomain,
                },
            },
        }),
    ];
}
/**
 * Sort marks groups by groups.
 */
const Sort = (options = {}) => {
    const { reverse = false, slice, channel, ordinal = true } = options, rest = __rest(options, ["reverse", "slice", "channel", "ordinal"]);
    return (I, mark) => {
        if (!ordinal) {
            return sortQuantitative(I, mark, Object.assign({ reverse,
                slice,
                channel }, rest));
        }
        return sortOrdinal(I, mark, Object.assign({ reverse, slice, channel }, rest));
    };
};
exports.Sort = Sort;
exports.Sort.props = {};
//# sourceMappingURL=sort.js.map