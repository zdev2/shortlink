"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sample = void 0;
// @ts-ignore medianIndex exist in d3-array@3.2.0, but @types/d3-array Expired.
const d3_array_1 = require("d3-array");
const order_1 = require("./utils/order");
const helper_1 = require("./utils/helper");
const lttb_1 = require("./utils/lttb");
function normalizeSample(strategy) {
    if (typeof strategy === 'function')
        return strategy;
    if (strategy === 'lttb')
        return lttb_1.lttb;
    const strategies = {
        first: (f) => [f[0]],
        last: (f) => [f[f.length - 1]],
        min: (f, X, Y) => [
            f[(0, d3_array_1.minIndex)(f, (i) => Y[i])],
        ],
        max: (f, X, Y) => [
            f[(0, d3_array_1.maxIndex)(f, (i) => Y[i])],
        ],
        median: (f, X, Y) => [
            f[(0, d3_array_1.medianIndex)(f, (i) => Y[i])],
        ],
    };
    const sampleFunction = strategies[strategy] || strategies.median;
    return (I, X, Y, thresholds) => {
        // Sepreate group to frames, then sample each frame.
        // Keep more data as possible.
        const frameSize = Math.max(1, Math.floor(I.length / thresholds));
        const frames = getFrames(I, frameSize);
        return frames.flatMap((frame) => sampleFunction(frame, X, Y));
    };
}
/**
 * Split the array into frame with each frameSize.
 */
function getFrames(I, frameSize) {
    const size = I.length;
    const frames = [];
    let i = 0;
    while (i < size) {
        frames.push(I.slice(i, (i += frameSize)));
    }
    return frames;
}
/**
 * The sample transform groups marks with specified groupBy fields, and
 * sample data for each group when data.length >= threshold(default = 2000).
 */
const Sample = (options = {}) => {
    const { strategy = 'median', thresholds = 2000, groupBy = ['series', 'color'], } = options;
    const sampleFunction = normalizeSample(strategy);
    return (I, mark) => {
        const { encode } = mark;
        const groups = (0, order_1.createGroups)(groupBy, I, mark);
        const [X] = (0, helper_1.columnOf)(encode, 'x');
        const [Y] = (0, helper_1.columnOf)(encode, 'y');
        return [
            groups.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
            mark,
        ];
    };
};
exports.Sample = Sample;
exports.Sample.props = {};
//# sourceMappingURL=sample.js.map