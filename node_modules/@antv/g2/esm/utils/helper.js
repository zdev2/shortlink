var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { lowerFirst, upperFirst, isPlainObject } from '@antv/util';
export function identity(x) {
    return x;
}
/**
 * Composes functions from left to right.
 */
export function compose(fns) {
    return fns.reduce((composed, fn) => (x, ...args) => fn(composed(x, ...args), ...args), identity);
}
/**
 * Composes single-argument async functions from left to right.
 */
export function composeAsync(fns) {
    return fns.reduce((composed, fn) => (x) => __awaiter(this, void 0, void 0, function* () {
        const value = yield composed(x);
        return fn(value);
    }), identity);
}
export function capitalizeFirst(str) {
    return str.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
}
export function error(message = '') {
    throw new Error(message);
}
export function copyAttributes(target, source) {
    const { attributes } = source;
    const exclude = new Set(['id', 'className']);
    for (const [key, value] of Object.entries(attributes)) {
        if (!exclude.has(key)) {
            target.attr(key, value);
        }
    }
}
export function defined(x) {
    return x !== undefined && x !== null && !Number.isNaN(x);
}
export function random(a, b) {
    return a + (b - a) * Math.random();
}
export function useMemo(compute) {
    const map = new Map();
    return (key) => {
        if (map.has(key))
            return map.get(key);
        const value = compute(key);
        map.set(key, value);
        return value;
    };
}
export function appendTransform(node, transform) {
    const { transform: preTransform } = node.style;
    const unset = (d) => d === 'none' || d === undefined;
    const prefix = unset(preTransform) ? '' : preTransform;
    node.style.transform = `${prefix} ${transform}`.trimStart();
}
export function subObject(obj, prefix) {
    return maybeSubObject(obj, prefix) || {};
}
export function maybeSubObject(obj, prefix) {
    const entries = Object.entries(obj || {})
        .filter(([key]) => key.startsWith(prefix))
        .map(([key, value]) => [lowerFirst(key.replace(prefix, '').trim()), value])
        .filter(([key]) => !!key);
    return entries.length === 0 ? null : Object.fromEntries(entries);
}
export function prefixObject(obj, prefix) {
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => {
        return [`${prefix}${upperFirst(key)}`, value];
    }));
}
export function filterPrefixObject(obj, prefix) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p) => key.startsWith(p))));
}
export function omitPrefixObject(obj, ...prefixes) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes.every((prefix) => !key.startsWith(prefix))));
}
export function maybePercentage(x, size) {
    if (x === undefined)
        return null;
    if (typeof x === 'number')
        return x;
    const px = +x.replace('%', '');
    return Number.isNaN(px) ? null : (px / 100) * size;
}
export function isStrictObject(d) {
    return (typeof d === 'object' &&
        !(d instanceof Date) &&
        d !== null &&
        !Array.isArray(d));
}
export function isUnset(value) {
    return value === null || value === false;
}
export function deepAssign(dist, src, maxLevel = 5, level = 0) {
    if (level >= maxLevel)
        return;
    for (const key of Object.keys(src)) {
        const value = src[key];
        if (!isPlainObject(value) || !isPlainObject(dist[key])) {
            dist[key] = value;
        }
        else {
            deepAssign(dist[key], value, maxLevel, level + 1);
        }
    }
    return dist;
}
//# sourceMappingURL=helper.js.map