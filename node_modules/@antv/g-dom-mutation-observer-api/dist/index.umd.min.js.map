{"version":3,"file":"index.umd.min.js","sources":["../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/typeof.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../../../node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/createClass.js","../src/dom/MutationRecord.ts","../src/dom/MutationObserver.ts"],"sourcesContent":["function _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nexport { _classCallCheck as default };","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nexport { _typeof as default };","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nexport { toPropertyKey as default };","import _typeof from \"./typeof.js\";\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nexport { toPrimitive as default };","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nexport { _createClass as default };","import type { IElement } from '@antv/g-lite';\n\nexport class MutationRecord {\n  static copy(original: MutationRecord) {\n    const record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n\n  addedNodes: IElement[] = [];\n  attributeName: string = null;\n  attributeNamespace: string = null;\n  nextSibling: IElement = null;\n  oldValue: string = null;\n  previousSibling: IElement = null;\n  removedNodes: IElement[] = [];\n  constructor(\n    public type: MutationRecordType,\n    public target: IElement,\n  ) {}\n}\n","/* eslint-disable max-classes-per-file */\nimport type { DisplayObject, IElement } from '@antv/g-lite';\nimport { ElementEvent, MutationEvent, runtime } from '@antv/g-lite';\nimport { MutationRecord } from './MutationRecord';\n\nlet uidCounter = 0;\nconst registrationsTable = new WeakMap<IElement, Registration[]>();\n\nexport class Registration {\n  private transientObservedNodes = [];\n\n  constructor(\n    public observer: MutationObserver,\n    public target: IElement,\n    public options?: MutationObserverInit,\n  ) {}\n\n  enqueue(record: MutationRecord) {\n    const { records } = this.observer;\n    const { length } = records;\n\n    // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n    if (records.length > 0) {\n      const lastRecord = records[length - 1];\n      const recordToReplaceLast = selectRecord(lastRecord, record);\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n\n    records[length] = record;\n  }\n\n  addListeners() {\n    this.addListeners_(this.target);\n  }\n\n  private addListeners_(node: IElement) {\n    const { options } = this;\n    if (options.attributes)\n      node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n\n    // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.addEventListener(ElementEvent.INSERTED, this, true);\n\n    if (options.childList || options.subtree)\n      node.addEventListener(ElementEvent.REMOVED, this, true);\n  }\n\n  removeListeners() {\n    this.removeListeners_(this.target);\n  }\n\n  removeListeners_(node: IElement) {\n    const { options } = this;\n    if (options.attributes)\n      node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n\n    // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n\n    if (options.childList)\n      node.removeEventListener(ElementEvent.INSERTED, this, true);\n\n    if (options.childList || options.subtree)\n      node.removeEventListener(ElementEvent.REMOVED, this, true);\n  }\n\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   */\n  // addTransientObserver(node: IElement) {\n  //   // Don't add transient observers on the target itself. We already have all\n  //   // the required listeners set up on the target.\n  //   if (node === this.target) return;\n\n  //   this.addListeners_(node);\n  //   this.transientObservedNodes.push(node);\n  //   let registrations = registrationsTable.get(node);\n  //   if (!registrations) registrationsTable.set(node, (registrations = []));\n\n  //   // We know that registrations does not contain this because we already\n  //   // checked if node === this.target.\n  //   registrations.push(this);\n  // }\n\n  removeTransientObservers() {\n    const { transientObservedNodes } = this;\n    this.transientObservedNodes = [];\n\n    transientObservedNodes.forEach(function (node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n\n      const registrations = registrationsTable.get(node);\n      for (let i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n  }\n\n  handleEvent(e: MutationEvent) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n\n    let record: MutationRecord;\n    let target: IElement;\n\n    switch (e.type) {\n      case ElementEvent.ATTR_MODIFIED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n\n        const name = e.attrName;\n        // @ts-ignore\n        const namespace = e.relatedNode.namespaceURI;\n        target = e.target as IElement;\n\n        // 1.\n        record = getRecord('attributes', target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n\n        // 2.\n        const oldValue =\n          e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n\n        forEachAncestorAndObserverEnqueueRecord(target, (options) => {\n          // 3.1, 4.2\n          if (!options.attributes) return;\n\n          // 3.2, 4.3\n          if (\n            options.attributeFilter &&\n            options.attributeFilter.length &&\n            options.attributeFilter.indexOf(name) === -1 &&\n            options.attributeFilter.indexOf(namespace) === -1\n          ) {\n            return;\n          }\n          // 3.3, 4.4\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n\n          // 3.4, 4.5\n          return record;\n        });\n\n        break;\n\n      // case 'DOMCharacterDataModified':\n      //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n      //   var target = e.target;\n\n      //   // 1.\n      //   var record = getRecord('characterData', target);\n\n      //   // 2.\n      //   var oldValue = e.prevValue;\n\n      //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n      //     // 3.1, 4.2\n      //     if (!options.characterData)\n      //       return;\n\n      //     // 3.2, 4.3\n      //     if (options.characterDataOldValue)\n      //       return getRecordWithOldValue(oldValue);\n\n      //     // 3.3, 4.4\n      //     return record;\n      //   });\n\n      //   break;\n\n      case ElementEvent.REMOVED:\n      // this.addTransientObserver(e.target as IElement);\n      // Fall through.\n      case ElementEvent.INSERTED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        target = e.relatedNode;\n        const changedNode = e.target as IElement;\n        let addedNodes: IElement[];\n        let removedNodes: IElement[];\n        if (e.type === ElementEvent.INSERTED) {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n        const { previousSibling } = changedNode;\n        const { nextSibling } = changedNode;\n\n        // 1.\n        record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling as IElement;\n        record.nextSibling = nextSibling as IElement;\n\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 2.1, 3.2\n          if (!options.childList) return;\n\n          // 2.2, 3.3\n          return record;\n        });\n    }\n\n    clearRecords();\n  }\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\nexport class MutationObserver {\n  nodes: IElement[] = [];\n  records: MutationRecord[] = [];\n  uid = uidCounter++;\n\n  constructor(public callback: MutationCallback) {}\n\n  observe(target: DisplayObject, options?: MutationObserverInit) {\n    // 1.1\n    if (\n      (!options.childList && !options.attributes && !options.characterData) ||\n      // 1.2\n      (options.attributeOldValue && !options.attributes) ||\n      // 1.3\n      (options.attributeFilter &&\n        options.attributeFilter.length &&\n        !options.attributes) ||\n      // 1.4\n      (options.characterDataOldValue && !options.characterData)\n    ) {\n      throw new SyntaxError();\n    }\n\n    let registrations = registrationsTable.get(target);\n    if (!registrations) registrationsTable.set(target, (registrations = []));\n\n    // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n    let registration: Registration;\n    for (let i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    }\n\n    // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes.push(target);\n    }\n\n    registration.addListeners();\n  }\n\n  disconnect() {\n    this.nodes.forEach((node) => {\n      const registrations = registrationsTable.get(node);\n      for (let i = 0; i < registrations.length; i++) {\n        const registration = registrations[i];\n        if (registration.observer === this) {\n          registration.removeListeners();\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n    this.records = [];\n  }\n\n  takeRecords() {\n    const copyOfRecords = this.records;\n    this.records = [];\n    return copyOfRecords;\n  }\n}\n\n// We keep track of the two (possibly one) records used in a single mutation.\nlet currentRecord: MutationRecord;\nlet recordWithOldValue;\n\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\nfunction getRecord(type: MutationRecordType, target: IElement) {\n  return (currentRecord = new MutationRecord(type, target));\n}\n\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\nfunction getRecordWithOldValue(oldValue: any) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = MutationRecord.copy(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\n\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record: MutationRecord) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\nfunction selectRecord(lastRecord: MutationRecord, newRecord: MutationRecord) {\n  if (lastRecord === newRecord) return lastRecord;\n\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))\n    return recordWithOldValue;\n\n  return null;\n}\n\nfunction removeTransientObserversFor(observer: MutationObserver) {\n  observer.nodes.forEach((node) => {\n    const registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer)\n        registration.removeTransientObservers();\n    });\n  });\n}\n\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target: IElement, callback) {\n  for (let node = target; node; node = node.parentNode as IElement) {\n    const registrations = registrationsTable.get(node);\n\n    if (registrations) {\n      for (let j = 0; j < registrations.length; j++) {\n        const registration = registrations[j];\n        const { options } = registration;\n\n        // Only target ignores subtree.\n        if (node !== target && !options.subtree) continue;\n\n        const record = callback(options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n}\n\n// This is used to ensure that we never schedule 2 callas to setImmediate\nlet isScheduled = false;\n\n// Keep track of observers that needs to be notified next time.\nlet scheduledObservers: MutationObserver[] = [];\n\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\nfunction scheduleCallback(observer: MutationObserver) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    // setImmediate(dispatchCallbacks);\n    if (typeof runtime.globalThis !== 'undefined') {\n      runtime.globalThis.setTimeout(dispatchCallbacks);\n    } else {\n      dispatchCallbacks();\n    }\n  }\n}\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n\n  isScheduled = false; // Used to allow a new setImmediate call above.\n\n  const observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort((o1, o2) => {\n    return o1.uid - o2.uid;\n  });\n\n  let anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    const queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n\n    // 2.4\n    if (queue.length) {\n      // @ts-ignore\n      observer.callback(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n\n  // 3.\n  if (anyNonEmpty) dispatchCallbacks();\n}\n"],"names":["_classCallCheck","a","n","TypeError","_typeof","o","Symbol","iterator","constructor","prototype","toPropertyKey","t","i","r","e","toPrimitive","call","String","Number","_defineProperties","length","enumerable","configurable","writable","Object","defineProperty","key","_createClass","MutationRecord","currentRecord","recordWithOldValue","type","target","this","addedNodes","attributeName","attributeNamespace","nextSibling","oldValue","previousSibling","removedNodes","value","original","record","slice","uidCounter","registrationsTable","WeakMap","Registration","observer","options","transientObservedNodes","records","recordToReplaceLast","lastRecord","newRecord","recordRepresentsCurrentMutation","selectRecord","scheduledObservers","push","isScheduled","runtime","globalThis","setTimeout","dispatchCallbacks","addListeners_","node","attributes","addEventListener","ElementEvent","ATTR_MODIFIED","childList","INSERTED","subtree","REMOVED","removeListeners_","removeEventListener","forEach","registrations","get","splice","stopImmediatePropagation","name","attrName","namespace","relatedNode","namespaceURI","getRecord","attrChange","MutationEvent","ADDITION","prevValue","forEachAncestorAndObserverEnqueueRecord","attributeFilter","indexOf","attributeOldValue","copy","getRecordWithOldValue","changedNode","undefined","callback","parentNode","j","registration","enqueue","observers","sort","o1","o2","uid","anyNonEmpty","queue","takeRecords","nodes","removeTransientObservers","removeTransientObserversFor","MutationObserver","characterData","characterDataOldValue","SyntaxError","set","removeListeners","addListeners","_this","copyOfRecords"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}